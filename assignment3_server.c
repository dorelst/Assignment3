/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "assignment3.h"
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>

/* This function generates the current time on the server side and sends it to the client */
serverResponse *
get_date_and_time_1_svc(void *argp, struct svc_req *rqstp)
{
	/*
	 * insert server code here
	 */

	static serverResponse  result_1;

	printf("\nMessage from client: Send me the current time!\n");

	char *current_time_string;
	time_t current_time;

	/* Current time is read in the form of epoch time */
	current_time = time(NULL);
	if (current_time == ((time_t)-1)) {
		printf("Failure to obtain teh current time.\n");
		exit(EXIT_FAILURE);
	}
	/* The epoch time is converted to month, day, time format and saved a as a string */
	current_time_string = ctime(&current_time);
	if (current_time_string == NULL) {
		printf("Failure to convert to current time.\n");
		exit(EXIT_FAILURE);
	}

	result_1.responseContent = current_time_string;
	
	return &result_1;
}


/* This function swaps to values from an array of integers */
void swap(int* first, int* second) {
	int temp = *first;
	*first = *second;
	*second = temp;
}


/* This function creates the partions used by the quick sort algorithm to sort a list of integers */
int create_sorting_partition(int arr[], int low, int high) {
	
	/* The pivot for this quick sort implementation is the last element */
	int pivot = arr[high];
	int i = low -1;
	int j;
	for(j= low; j<=high-1; j++) {
		/* If the element that is evaluated is smaller than the pivot than index i for the smaller elements is increased */
		/* and current element that is evaluated (on j position) is swap with element on the i position (the one before the */
		/* last smaller elemetn than pivot) */
		if (arr[j]<pivot) {
			i++;
			swap(&arr[i], &arr[j]);
		}
	}
	swap(&arr[i+1], &arr[high]);
	
	return (i+1);
}


/* This function recursively sort the list of integers using quick sort algorithm */
void quickSortList(int arrayToBeSroted[], int low, int high) {
	if (low<high) {
		/* Creates the index pi for the two partition that are used to sort the list */
		int pi = create_sorting_partition(arrayToBeSroted, low, high);
		
		/* The quicksorList function is applied recursively on the two partition determined by index pi */
		quickSortList(arrayToBeSroted, low, pi-1);
		quickSortList(arrayToBeSroted, pi+1, high);
	}
}


serverResponse *
sort_list_integers_1_svc(serverResponse *argp, struct svc_req *rqstp)
{
	/*
	 * insert server code here
	 */

	static serverResponse  result_2;

	printf("\nMessage from client: Sort the following list: %s!\n", argp->responseContent);

	char receivedFromClient1[2000]="";
	strcpy(receivedFromClient1, argp->responseContent);
	char receivedFromClient2[2000]="";
	strcpy(receivedFromClient2, argp->responseContent);

	int i;
	int sizeOfArray = 0;
			
	/* "+" is the marker for the end of a cell value in the stringify lsit of integers */
	char delim[] = "+";

	char *ptr1 = strtok(receivedFromClient1, delim);

	/* Size of the list calculated */
	i=0;
	while(ptr1 != NULL)
	{
		sizeOfArray++;
		ptr1 = strtok(NULL, delim);
	}
		
	int listOfIntegers[sizeOfArray];

	char *ptr2 = strtok(receivedFromClient2, delim);
	
	/* The list of integers is generated from the stringify version received from the client */
	i=0;
	while(ptr2 != NULL)
	{
		listOfIntegers[i] = atoi(ptr2);
		ptr2 = strtok(NULL, delim);
		i++;
	}

	
	/* int n = sizeof(listOfIntegers)/sizeof(listOfIntegers[0]); */
	quickSortList(listOfIntegers, 0, sizeOfArray-1);

	char build_list[2000]="";

	/* The sorted list is converted back to a string a send to client */
	for (i=0; i<sizeOfArray; i++) {
		char buffer[5];
		sprintf(buffer, "%d", listOfIntegers[i]);
		strcat(build_list, buffer);
		/* "+" is the marker for the end of a cell value in the stringify lsit of integers */
		strcat(build_list, "+");
		buffer[0] = '\0';
	}

	result_2.responseContent = build_list;
	return &result_2;
}


/* This function generates a list of files and folders present in the current folder, from wheren the server application is running */
serverResponse *
list_of_files_current_folder_1_svc(void *argp, struct svc_req *rqstp)
{

	/*
	 * insert server code here
	 */

	static serverResponse  result_3;

	printf("\nMessage from client: Send me the list of files on the server!\n");

	
	char *build_list = (char *) calloc (2000, sizeof(char));

	DIR *d;
    	struct dirent *dir;
	/* Opens the current folder */
    	d = opendir(".");
   	if (d)
    	{
		/* adds every item found to the list */
        		while ((dir = readdir(d)) != NULL)
        		{
			char* file = dir->d_name;
			char* space = " ";
            		strcat(build_list, file);
			strcat(build_list, space);
        		}
        		closedir(d);
    	}

	strcat(build_list, "\0");
	result_3.responseContent = build_list;
	
	free(build_list);

	return &result_3;
}


/* This function extract the numbers of rows and columns from a 2D Array that was converted to a string */
void extractRowsAndColumns(char* stringMatrix, int *dimMatrix) {
	
	char *tempMatrix = (char *) calloc (2000, sizeof(char));
	strcpy(tempMatrix, stringMatrix);
	
	int rows = 0, columns=0;
	/* "#" is the marker for the end of a row in the stringify matrix */
	const char delim[] = "#";

	char *ptr1 = strtok(stringMatrix, delim);


	while(ptr1 != NULL)
	{
		rows++;
		ptr1 = strtok(NULL, delim);
	}
	
	/* "+" is the marker for the end of a cell value in the stringify matrix */
	const char delim1[] = "#";
	const char delim2[] = "+";
	
	ptr1 = strtok(tempMatrix, delim1);
	char *line = strtok(ptr1, delim2);


	while(line != NULL)
	{
		columns++;
		line = strtok(NULL, delim2);
	}

	dimMatrix[0] = rows;
	dimMatrix[1] = columns;
	
	free(tempMatrix);

}


/* This function extract a 2D Array of integers from a matrix that was converted to a string */
void extractMatrix(char *stringMatrix, int* matrix, int *dimArray) {

	
	char *ptr1, *ptr2, *line;
	char *buffer1, *buffer2;
	
	int i=0, j=0;

	/* "#" is the marker for the end of a row in the stringify matrix */
	/* "+" is the marker for the end of a cell value in the stringify matrix */
	const char delim1[] = "#";
	const char delim2[] = "+";	

	for( ptr1=strtok_r(stringMatrix, delim1, &buffer1) ; ptr1!=NULL ; ptr1=strtok_r(NULL, delim1, &buffer1) ) {
		j=0;
		for( ptr2=strtok_r(ptr1, delim2, &buffer2) ; ptr2!=NULL ; ptr2=strtok_r(NULL, delim2, &buffer2) ) {
			matrix[i*dimArray[1]+j] = atoi(ptr2);
			j++;
		}
		i++;
	}
}


/* This function prints to the screen the content of 2D Array */
void printMatrix(int* matrix, int rows, int columns) {
	
	int i, j;
	printf("\n");
	for(i=0; i<rows; i++) {
		for(j=0; j<columns; j++) {
			printf("m[%d][%d]=%d  ",i,j,matrix[i*columns+j]);
		}
		printf("\n");
	}

}


/* This function multiply two matrixes sent by the client and returns the result converted into a string */
serverResponse *
matrix_multiply_1_svc(inputMatrixes *argp, struct svc_req *rqstp)
{
	/*
	 * insert server code here
	 */

	printf("\nMessage from client: Multiply the two matrixes sent!\n");

	static serverResponse  result_4;

	int m1dim[2] = {0,0};
	int m2dim[2] = {0,0};
	
	char *tempMatrix1 = (char *) calloc (2000, sizeof(char));
	char *tempMatrix2 = (char *) calloc (2000, sizeof(char));

	strcpy(tempMatrix1, argp->matrix1);
	strcpy(tempMatrix2, argp->matrix2);

	/* The numbers of rows and columns are extracted here from the two stringify matrixes received */
	extractRowsAndColumns(tempMatrix1, m1dim);
	extractRowsAndColumns(tempMatrix2, m2dim);
	
	int m1[m1dim[0]][m1dim[1]];
	int m2[m2dim[0]][m2dim[1]];

	m1[0][0]=0;
	m2[0][0]=0;
	
	strcpy(tempMatrix1, argp->matrix1);
	strcpy(tempMatrix2, argp->matrix2);

	/* The two matrixes that will be multiplied are extracted from the two stringify matrixes received */
	extractMatrix(tempMatrix1, *m1, m1dim);	
	extractMatrix(tempMatrix2, *m2, m2dim);

	free(tempMatrix1);
	free(tempMatrix2);

	printf("\nThe two matrixes received from the client:");
	printf("\n	First matrix:");
	printMatrix(*m1, m1dim[0], m1dim[1]);
	printf("\n	Second matrix:");
	printMatrix(*m2, m2dim[0], m2dim[1]);



	int i, j, k, m, val;
	int multipliedMatrix[m1dim[0]][m2dim[1]];
	char *responseToClient = (char *) calloc (2000, sizeof(char));
	char buffer[5];
	
	/* The matrix multiplication is done here */
	/* There isn't any check for the number of columns to equals the number of rows, because when the matrixes are input the user is asked */
	/* only for the number of rows and columns for the first matrix, and the number of columns for the second matrix */
	/* and the number of rows for the second matrix is iniated with the value for the number of columns for the first matrix */ 
	for (i=0; i<m1dim[0];i++) {
		for(j=0;j<m2dim[1];j++) {
			val=0;
			k=0;
			/* The value for each element is calculated in this while loop */
			while (k<m1dim[1]) {
				val = val + m1[i][k]*m2[k][j];
				k++;
			}
			multipliedMatrix[i][j] = val;
			
			/* The result of the matrix multiplications is converted to a string here */
			sprintf(buffer, "%d", val);
			strcat(responseToClient, buffer);
			strcat(responseToClient, "+");
			buffer[0] = '\0';

		}
		strcat(responseToClient, "#");
	}		


	printf("\nThe result of these matrixes multiplication is:");
	printMatrix(*multipliedMatrix, m1dim[0], m2dim[1]);

	result_4.responseContent = responseToClient;
	
	free(responseToClient);

	return &result_4;
}


/* Function to handle erros generated by encryption/decryption functions */
void handleErrors(char *message) {

	printf("\nAn error happended! Location: %s", message);

}


/* Function to encrypt a string */
int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext)
{
    	EVP_CIPHER_CTX *ctx;

	int len;

    	int ciphertext_len;

    		/* Create and initialise the context */
    	if(!(ctx = EVP_CIPHER_CTX_new()))
        		handleErrors("Create and initialise the context");

    		
     		/* Initialise the encryption operation. A 256 bit AES key is used. The
     		 IV size is 128 bits */
     		
    	if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
        		handleErrors("Initialise the encryption operation");

     		/* Provide the message to be encrypted, and obtain the encrypted output.*/
    	if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
        		handleErrors("Obtain the encrypted output");
    	ciphertext_len = len;


     		/* Finalise the encryption.*/
     	if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))
        		handleErrors("Finalise the encryption");
    	ciphertext_len += len;

    		/* Clean up */
    	EVP_CIPHER_CTX_free(ctx);

    	return ciphertext_len;
}


/* This function trims the trailing blanck characters generated by the decrypte function */
void trimTrailingSpaces(unsigned char *plaintext)
{
    	int i,j;
	
	/* Set the starting position from the end of the string, skipping the new line and end of string characters */
    	i = strlen(plaintext)-2;
	
	/* The encryption function generates ending backspace ASCI codes that need to be deleted */
    	while(((plaintext[i] == ' ') || (plaintext[i] == 8)) && (i>0))
    	{
        		i--;
    	}
		/* Mark next character to last non-white space character as NULL */
	plaintext[i + 1] = '\0';

}


/* This function encrypt */
int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key, unsigned char *iv, unsigned char *plaintext)
{
	EVP_CIPHER_CTX *ctx;

    	int len;

    	int plaintext_len;
	

    		/* Create and initialise the context */
    	if(!(ctx = EVP_CIPHER_CTX_new()))
        		handleErrors("Create and initialise the context");

     		/* Initialise the decryption operation. A 256 bit AES key is used. The
     		IV is 128 bits */
       	if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
        	handleErrors("Initialise the decryption operation");

     		/* Provide the message to be decrypted, and obtain the plaintext output */
    	if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
        		handleErrors("Obtain the plaintext output");
    	plaintext_len = len;
	
     		/* Finalise the decryption.*/
	if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))
        		handleErrors("Finalise the decryption");

	/* Remove the trailing blanck spaces and backspace characters */
	trimTrailingSpaces(plaintext);
    	plaintext_len = strlen(plaintext);

    		/* Clean up */
    	EVP_CIPHER_CTX_free(ctx);

    	return plaintext_len;
}


/* This function set the context for encryption or decryption of a string */
void doEncryptionDecryption(unsigned char *textprocessed, int choice) {
	
    		/* A 256 bit key */
    	unsigned char *key = (unsigned char *)"01234567890123456789012345678901";

    		/* A 128 bit IV */
    	unsigned char *iv = (unsigned char *)"0123456789012345";

    	 	/* Buffer for ciphertext.*/
    	/*static unsigned char ciphertext[1920];*/

    		/* Buffer for the decrypted text */
    	/*static unsigned char decryptedtext[1920];*/

	unsigned char *tempMessage = (char *) calloc (1920, sizeof(char));
	strcpy(tempMessage, textprocessed);

    	int decryptedtext_len, ciphertext_len;

    
	if (choice == 1) {
			/* Encrypt the plaintext */
    		ciphertext_len = encrypt (tempMessage , strlen(textprocessed), key, iv, textprocessed);

	} else {
			/* Decrypt the ciphertext */
		decryptedtext_len = decrypt(tempMessage , strlen(textprocessed), key, iv, textprocessed);
		

    			/* Add a NULL terminator to make the text printable */
    		/*decryptedtext[decryptedtext_len] = '\0';*/

	}

	free(tempMessage);
}


/* This function implements the string reverse function encrypting the result before sending it back to the client */
serverResponse *
reverse_encryption_1_svc(serverResponse *argp, struct svc_req *rqstp)
{

	/*
	 * insert server code here
	 */

	static serverResponse  result_5;

	printf("\nString received: %s\n", argp->responseContent);
	unsigned char *receivedFromClient = (char *) calloc (1920, sizeof(char));

	strcpy(receivedFromClient, argp->responseContent);

	/* The encrypted string received from the client is decrypted here */
	doEncryptionDecryption(receivedFromClient, 2);
	printf("\nDecrypted receivde from client = %s\n", receivedFromClient); 
	

	int stringLength = strlen(receivedFromClient);
	int i,j;
	char temp;
	i=0;
	j=stringLength-2;
	
	/* The received string is reversed in this while loop */
	while (i<=((stringLength/2)-1)) {
		temp = receivedFromClient[i];
		receivedFromClient[i] = receivedFromClient[j];
		receivedFromClient[j] = temp;
		i++;
		j--;
	}

	/* The reversed result is encrypted */
	printf("\nReverted String: %s\n", receivedFromClient);
	doEncryptionDecryption(receivedFromClient,1);

	printf("\nEncrypted answer is: %s\n", receivedFromClient);	

	result_5.responseContent = receivedFromClient;

	free(receivedFromClient);

	return &result_5;
}
